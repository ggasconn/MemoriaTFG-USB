<!-- Leave a blank line before the title -->

# Contribuciones

## Aportación de Guillermo Gascón Celdrán {.unnumbered}

Durante mi tercer año de carrera cursé la optativa de *Arquitectura Interna de Linux y Android* y cuando se acercaba el final de la asignatura Juan Carlos nos presentó diferentes propuestas de Trabajos de Fin de Grado relacionados con los conceptos aprendidos, entre las cuáles se encontraba esta. Desde aquél entonces le confirmé mi interés por realizar este proyecto ya que me motivaba mucho el desarrollar un dispositivo que posteriormente se pudiera usar para que otros alumnos, como yo lo fuí, aprendieran lo máximo posible sobre USB.

Cuando recibí la confirmación por parte de Juan Carlos de que podía realizar dicho TFG comencé a informarme sobre el protocolo USB, siguiendo todo lo que habíamos aprendido en clase y profundizando más con lecturas de libros y documentos. Este periodo de lectura inicial que hice me ha servido para entender los nuevos conceptos a los que nos hemos ido enfrentando durante el desarrollo de este trabajo.

Posteriormente, una vez finalizado el curso *2021-2022*, Juan Carlos nos ofreció prestarnos algo de material antes de verano para comenzar a investigar sobre los periféricos que ibamos a utilizar, así como con el entorno de desarrollo y el *framework V-USB*. Sin dudarlo acepté y durante los meses de verano estuve aprendiendo a usar tanto el anillo de *LED* circular, como un *LED RGB* individual que hace uso de un protocolo diferente para funcionar, además aprendí en profundidad como funciona el entorno de programación *AVR* y conseguí utilizar las diferentes herramientas que nos proporciona para compilar y subir nuevo código al microcontrolador con éxito.

Ya más entrados en el curso *2022-2023*, comencé a investigar sobre cómo estaba construido el dispositivo que tomamos de referencia, el *Blinkstick Strip*, consiguiendo comprender su firmware al completo y familiarizándome también con su construcción hardware. Esto me permitió crear una primera versión de prueba del firmware con la que pude hacer que el ordenador reconociera el microcontrolador bajo el nombre de *PwnedDevice* y con los parámetros definidos por mí.

Después de esto, comencé a investigar sobre cómo podíamos incluir dentro del firmware de prueba que ya teníamos el código necesario para utilizar el anillo de *LED*. Finalmente, tras realizar algunos ajustes de configuración y modificar alguna función, conseguí incluir con éxito una librería que nos permitía controlar el anillo por completo. Posteriormente, mejoré la eficiencia cuando se usa este periférico guardando ciertos datos sobre él que permitían ahorrar tiempo y cálculos.

Una vez implementado el anillo, me puse con la función de lectura. Esta función es la que se ejecuta cuando el ordenador pide al dispositivo un cierto número de datos y tuve que aprender cómo funciona *V-USB* por dentro y cómo gestiona este tipo de llamadas para finalmente implementar con éxito la función y hacer que cuando el dispositivo reciba una lectura devuelva la cadena *Hello World! I'm pwnedDevice ;)*.

Después de la función de lectura empecé a implementar la integración en el firmware de un sensor de temperatura, esta investigación me llevo mucho tiempo y finalmente me fue imposible integrar este periférico dentro de *V-USB*. Actualmente desconocemos el problema que ocasiona mezclar el sensor de temperatura con el *framework V-USB*, ya que sin este último, el sensor funciona como se espera. Al mismo tiempo, ayudé a Javier a integrar una pantalla *OLED* en el proyecto, realizando las modificaciones necesarias en el firmware para dotar de funcionalidad a esta pequeña pantalla.

A continuación, estuve aprendiendo a usar los timers internos del microcontrolador que terminamos usando, el *ATMega328p*. Esto me llevó un tiempo puesto que era mi primera vez trabajando con hardware de este tipo, pero finalmente conseguí generar diferentes señales *PWM* con las que pude controlar el buzzer y el diodo *LED*, haciendo sonar incluso una canción de cumpleaños feliz.

Por último dentro del desarrollo del firmware, integré el endpoint de tipo *INTERRUPT IN* e implementé con éxito la devolución de un buffer de 8 bytes relleno de información cada vez que se recibe una transferencia de este tipo.

Durante todo el desarrollo del firmware, he creado también diferentes utilidades que hacen uso de la librería *libusb* en *C* y en *Python*, que me permitieron probar los nuevos periféricos de una manera rápida debido a la simplicidad con la que se creaban los mensajes para interactuar con el microcontrolador.

A su vez, también estuve desarrollando los drivers que vienen dentro del paquete de drivers de ejemplo que ofrece este proyecto. Con ayuda de Juan Carlos, hemos conseguido exprimir las diferentes partes de la *API* que ofrece *USB* Core quedando un conjunto de ejemplo ideal para alumnos que se introducen en este campo.

Como último retoque, una vez tuvimos el prototipo hardware funcionando, cree una pequeña placa prototipo con los componentes soldados quedando un dispositivo *USB* más compacto que cuando se encontraba todo conectado a la placa de desarrollo.

En cuanto al desarrollo de esta memoria, mis principales contribuciones han sido los capítulos que tratan sobre *Tecnología USB, Proyecto V-USB y Firmware*, junto con algunas aportaciones tanto en la introducción como en las conclusiones, además de los apéndices que se ilustran de breves manuales sobre aspectos relavantes con los que hemos tenido que trabajar.

Y estas han sido mis aportaciones al proyecto, junto con mucho tiempo de investigacion que ha acompañado a todas las etapas del desarrollo tanto software como hardware.


## Aportación de Javier Rodríguez-Avello Tapias {.unnumbered}

Una de las asignaturas que más me han llamado la atención de la carrera ha sido *Sistemas Operativos*, asignatura que cursé en el año *2021-2022* con Juan Carlos. La programación a bajo nivel en C, y todas las posibles funcionalidades y arquitectura del sistema operativo *Linux* que se imparten en esta asignatura despertó mi interés en poder realizar un Trabajo de fin de Grado relacionado con este área, además del enfoque de mi titulación enfocada más a la parte Hardware. Es por ello por lo que decidí consultar a Juan Carlos sobre los posibles proyectos relacionados con este área de programación. Al hacerlo, Juan Carlos me recomendó cursar la asignatura *Arquitectura Interna de Linux y Android* que él impartía, para profundizar en aspectos de programación a nivel de Kernel que *Sistemas Operativos* no cubría, matriculándome en ella al siguiente año. Juan Carlos me propuso este proyecto al estar relacionado con el desarrollo de un firmware puramente en C para un dispositivo similar al Blinkstick de la asignatura LIN, teniendo para ello que profundizar en protocolos más avanzados como USB y desarrollo de drivers más complejos. En la asignatura de LIN estudiaría la comunicación USB mediante endpoints de tipo *control*, necesarios para la comunicación con el dispositivo Blinkstick. Este proyecto tiene como uno de los objetos el estudio de otros tipos drivers, como los que utilizan endpoints *Interrupt* *IN*, fuera del ámbito de estudio de la asignatura.

En ese mismo verano, tras haber tenido una primera reunión con Guillermo y los tutores del proyecto, decidimos estudiar a fondo la placa Digispark. Para ello, necesité adquirir conocimientos sobre USB, con especial foco en la parte relacionada con las clases USB y haciendo hincapié en la clase HID que posteriormente haríamos uso en este proyecto. Por otra parte, invertí tiempo en estudiar cómo se realiza la comunicación con el chip que alberga la placa Digispark, el ATTiny85. Para ello, y teniendo en mis manos esta la placa con el anillo de LEDs de Neopixel, me puse a buscar documentación sobre estos dispositivos, características técnicas y posibles proyectos con funcionalidades similares. Tras realizar diversas búsquedas, tanto ejemplos de la propia librería de NeoPixel como en otras plataformas como GitHub, me di cuenta de que este dispositivo tiene multitud de aplicaciones, muchas de ellas desarrolladas con el entorno de Arduino. Por ello, decidí instalar el entorno en mi equipo para poder probar código de ejemplo, y estudiar su funcionamiento con la tira de LEDs de NeoPixel y un LED RGB. Me di cuenta de que para poder *flashear* firmware en la placa, se requiere tener el programador de Micronucleus en el entorno de AVR, una utilidad que incorpora Arduino, ventaja si se depende de este entorno para desarrollar software, pero que no era nuestro objetivo depender de Arduino. 

Posteriormente, empezamos a estudiar el *framework* de V-USB, su funcionamiento y arquitectura interna. Para poder testear la funcionalidad de este firmware, tuve varias reuniones con Guillermo, en las que estuvimos realizando pruebas con un firmware de ejemplo para ver cómo funciona este *framework*. Posteriormente, conseguimos implementar la funcionalidad para V-USB que controla el LED circular de NeoPixel, desarrollando un programa de usuario basado en la API HID de USB que establece todos los colores de la cadena de color verde, rojo y azul; y posteriormente cambia el color de cada LED de forma individual mediante un bucle. De esta forma, conseguí aprender el protocolo que usa la tira de LEDs y estudiar en profundidad el funcionamiento y comunicación mediante *report-IDs* de V-USB, necesaria para el siguiente periférico que implementé.

Mientras Guillermo se encargó de documentarse y desarrollar el código correspondiente al sensor de temperatura, yo me encargué de estudiar el desarrollo correspondiente a una pantalla LCD 2x16 con un módulo I2C. Tras buscar distintos ejemplos y librerías que hagan uso de esta pantalla, y hacer diversas pruebas y modificaciones con estos proyectos de ejemplo, resultó complejo implementar la funcionalidad para mostrar cadenas de texto utilizando el ATTiny85, ya que todos estos proyectos utilizaban otros microchips de AVR con implementaciones basadas en V-USB, pero con mucha configuración adaptada a cada hardware y funcionalidad específica, lo que aumentaba su complejidad a la hora de adaptarlo a nuestro firmware. Gran parte de mi tiempo se invirtió en poder desarrollar la funcionalidad correspondiente a la gestión de esta pantalla, utilizando para ello distintas librerías de I2C. Finalmente, por incompatibilidades del propio firmware y del protocolo I2C, no fui capaz de integrarla. Basándome en otro proyecto que hacía uso de una pantalla LCD tipo OLED en ATmega328p (en ese momento migramos el firmware a este microchip), decidí investigar sobre la librería que dotaba de funcionalidad a este tipo de pantalla. Esta nueva pantalla difería de la original al ser más grande y tener incorporado el protocolo I2C de fábrica, a diferencia de la pantalla original a la que tuve que soldar este módulo. Finalmente, con ayuda de Guillermo para su integración en el firmware, conseguí incorporar este periférico al proyecto, cuya funcionalidad inicial sería como *output* para hacer debug, aunque posteriormente, gracias a la ayuda de Cristian, incorporamos una función de depuración a modo de *printk()* para mostrar mensajes por puerto serie, ya que la placa NANO incorpora este componente. 

Otra contribución al proyecto fue la creación de distintos perfiles. En una primera implementación, se crearon dos perfiles para el ATmega328p y para el ATTiny85, cada uno con configuración específica de cada chip, aunque finalmente, al establecerse como prototipo final la placa NANO que incorpora el ATmega328p (al ser más útil por las ventajas que incorpora frente a ATTiny85), se decidió implementar una configuración de perfiles para que los periféricos actuasen según una determinada funcionalidad definida en cada perfil. Para ello, desarrollamos un fichero `deviceconfig.h` donde, mediante macros, se activan los distintos perfiles.

Como último punto, se ha desarrollado un driver para gestionar la pantalla OLED, haciendo uso de endpoints tipo *control*, en el que se escriben cadenas de texto a la pantalla mediante un fichero especial de caracteres en `/dev`. Para este desarrollo, gran parte de la ayuda se la debo a Guillermo, ya que en los últimos meses, por temas laborales, he estado muy ajustado de tiempo, al igual que en la implementación del driver que hace uso de endpoints tipo *Interrupt* *IN*, con una arquitectura muy interesante (no se explica en LIN), del que se ha encargado del desarrollo en su totalidad Guillermo.

Para la redacción de esta memoria, me he centrado en los capítulos de Hardware y Drivers desarrollados en el proyecto, habiendo hecho otras aportaciones en el resto de capítulos de esta memoria.
